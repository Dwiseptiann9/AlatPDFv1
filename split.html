<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pisah PDF (Kode Unik)</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>

  <header class="page-header">
    <a href="index.html" class="back-link">‚Üê Kembali ke Portal</a>
    <h1>Pisah PDF (Kode Unik)</h1>
    <p>Pisahkan PDF besar (misal: hasil mail merge) berdasarkan daftar kode unik dari file .txt.</p>
  </header>

  <main class="container">
    <div class="card">
      
      <label class="setting-label">1. PDF Besar yang Akan Dipisah</label>
      <div id="pdfDrop" class="dropzone">Klik / Drop 1 File PDF</div>
     
      <label class="setting-label">2. File Teks (.txt) berisi Kode Unik</label>
      <div id="txtDrop" class="dropzone">Klik / Drop 1 File .txt</div>
      
      <label class="setting-label">3. Akhiran Nama File (Opsional)</label>
      <input type="text" id="suffixInput" class="input-field" placeholder="Contoh: _terpisah atau -LAPORAN">
      
    </div>
    
    <div id="fileListContainer">
      </div>

    <button id="startButton" class="button-primary button-large" disabled>Mulai Proses Pemisahan</button>
    <div id="output" class="status-box">Menunggu file...</div>
    
  </main>

  <script>
    // Konfigurasi worker untuk pdf.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    
    const { PDFDocument } = PDFLib;
    const { JSZip } = window;
    
    // Ambil elemen DOM
    const pdfDropZone = document.getElementById('pdfDrop');
    const txtDropZone = document.getElementById('txtDrop');
    const startButton = document.getElementById('startButton');
    const output = document.getElementById('output');
    const fileListContainer = document.getElementById('fileListContainer');
    const suffixInput = document.getElementById('suffixInput');

    // Tempat penyimpanan file
    let pdfFile = null;
    let txtFile = null;
    let pdfFileBuffer = null; 
    let isProcessing = false;

    // --- 1. Pengaturan Dropzone (Sudah diperbaiki) ---
    function setupDropzone(element, expectedMimeType, callback) {
      const handleFile = (file) => {
        if (!file) return;
        const isValidType = file.type === expectedMimeType || (expectedMimeType === "text/plain" && file.name.endsWith(".txt"));
        if (isValidType) {
          callback(file);
        } else {
          alert(`File tidak valid. Harap pilih atau drop file ${expectedMimeType}`);
        }
      };
      const clickHandler = () => {
        if (isProcessing) return;
        const input = document.createElement("input");
        input.type = "file";
        input.accept = expectedMimeType;
        input.multiple = false;
        input.onchange = (e) => handleFile(e.target.files[0]);
        input.click();
      };
      const dragOverHandler = (e) => {
          e.preventDefault(); 
          if (!isProcessing) element.classList.add("dragover"); 
      };
      const dragLeaveHandler = () => element.classList.remove("dragover");
      const dropHandler = (e) => {
        e.preventDefault();
        if (isProcessing) return;
        element.classList.remove("dragover");
        handleFile(e.dataTransfer.files[0]);
      };
      element.removeEventListener("click", clickHandler);
      element.removeEventListener("dragover", dragOverHandler);
      element.removeEventListener("dragleave", dragLeaveHandler);
      element.removeEventListener("drop", dropHandler);
      element.addEventListener("click", clickHandler);
      element.addEventListener("dragover", dragOverHandler);
      element.addEventListener("dragleave", dragLeaveHandler);
      element.addEventListener("drop", dropHandler);
    }
    
    setupDropzone(pdfDropZone, "application/pdf", async (file) => {
        try {
            output.textContent = "Membaca file PDF...";
            output.className = "status-box status-processing";
            pdfFileBuffer = await file.arrayBuffer();
            pdfFile = file;
            pdfDropZone.textContent = `‚úÖ File PDF: ${file.name}`;
            pdfDropZone.classList.add("has-file");
            checkReadyState();
        } catch (e) {
            output.textContent = "Gagal membaca file PDF.";
            output.className = "status-box status-error";
            alert("Gagal membaca file PDF: " + e.message);
            resetUI();
        }
    });
    
    setupDropzone(txtDropZone, "text/plain", (file) => {
        txtFile = file;
        txtDropZone.textContent = `‚úÖ File Teks: ${file.name}`;
        txtDropZone.classList.add("has-file");
        checkReadyState();
    });
    
    function checkReadyState() {
        if (pdfFile && txtFile) {
            output.textContent = "‚úÖ Siap memisahkan PDF berdasarkan file teks.";
            output.className = "status-box status-success";
            startButton.disabled = false;
        } else {
             if (!pdfFile && !txtFile) output.textContent = "Menunggu file PDF dan file .txt...";
             else if (!pdfFile) output.textContent = "Menunggu file PDF...";
             else output.textContent = "Menunggu file .txt...";
             output.className = "status-box";
             startButton.disabled = true;
        }
    }
    function resetUI() {
        pdfFile = null; txtFile = null; pdfFileBuffer = null; isProcessing = false;
        pdfDropZone.textContent = "Klik / Drop 1 File PDF";
        txtDropZone.textContent = "Klik / Drop 1 File .txt";
        pdfDropZone.classList.remove("has-file"); txtDropZone.classList.remove("has-file");
        fileListContainer.innerHTML = ''; 
        suffixInput.value = ''; 
        startButton.disabled = true;
        output.textContent = "Menunggu file..."; output.className = "status-box";
    }

    // --- 2. Logika Inti Pemisahan ---
    
    // DIPERBARUI: Logika startButton diubah untuk pengurutan
    startButton.addEventListener('click', async () => {
        if (isProcessing || !pdfFile || !txtFile || !pdfFileBuffer) return;
        isProcessing = true; startButton.disabled = true; fileListContainer.innerHTML = ''; 
        output.textContent = "üöÄ Memulai proses... Harap tunggu."; output.className = "status-box status-processing";
        
        const suffix = suffixInput.value; 
        let pdfjsDoc;
        try {
            // Langkah 1: Baca file TXT (Mendapatkan urutan yang benar)
            output.textContent = `Membaca file .txt... (Langkah 1 dari 5)`;
            const uniqueCodes = await readTxtFile(txtFile); // Ini adalah array [CODE_A, CODE_B, CODE_C]
            if (uniqueCodes.length === 0) throw new Error("File .txt kosong atau tidak berisi baris teks yang valid.");
            
            // Langkah 2: Baca PDF
            output.textContent = `Membaca file PDF... (Langkah 2 dari 5)`;
            const pdfjsData = pdfFileBuffer.slice(0); 
            const loadingTask = pdfjsLib.getDocument({ data: pdfjsData });
            pdfjsDoc = await loadingTask.promise;
            const totalPageCount = pdfjsDoc.numPages;

            // Langkah 3: Buat "Peta Penemuan" (Tidak diurutkan)
            output.textContent = `Memindai ${totalPageCount} halaman... (Langkah 3 dari 5)`;
            // foundEntries adalah array [{code, page}, ...] TIDAK DIURUTKAN
            const foundEntries = await createSplitMap(pdfjsDoc, uniqueCodes); 
            
            if (foundEntries.length === 0) throw new Error("Tidak ada satupun kode unik yang ditemukan di dalam PDF. Periksa Console Log (F12) untuk detail.");
            
            // --- LOGIKA BARU UNTUK PENGURUTAN ---
            output.textContent = `Menghitung rentang halaman... (Langkah 4 dari 5)`;
            
            // 4a. Buat Peta Rentang Halaman (berdasarkan urutan halaman)
            // Urutkan berdasarkan halaman HANYA untuk menentukan rentang
            const sortedByPage = [...foundEntries].sort((a, b) => a.page - b.page);
            const rangeMap = new Map();
            for (let i = 0; i < sortedByPage.length; i++) {
                const entry = sortedByPage[i];
                const startPage = entry.page;
                let endPage;
                
                const isLastEntry = (i === sortedByPage.length - 1);
                if (isLastEntry) {
                    endPage = totalPageCount;
                } else {
                    endPage = sortedByPage[i + 1].page - 1; // Halaman sebelum kode berikutnya
                }
                
                if (endPage < startPage) endPage = startPage; // Jika 2 kode di halaman yg sama
                
                rangeMap.set(entry.code, { start: startPage, end: endPage });
            }
            
            // 4b. Buat Daftar Proses Akhir (berdasarkan urutan TXT)
            const processingList = [];
            for (const code of uniqueCodes) {
                const range = rangeMap.get(code); // Ambil rentang halaman dari peta
                if (range) {
                    // Jika kode ditemukan, tambahkan ke daftar proses
                    processingList.push({
                        code: code,
                        startPage: range.start,
                        endPage: range.end
                    });
                }
            }
            
            if (processingList.length === 0) {
                // Ini terjadi jika kode di TXT ada, tapi tidak satupun ditemukan di PDF
                throw new Error("Kode di .txt tidak ada yang cocok dengan isi PDF.");
            }
            // --- AKHIR LOGIKA BARU ---

            output.textContent = `Rencana pemisahan dibuat. ${processingList.length} file akan dibuat.`;
            renderPreviewList(processingList, suffix); // Kirim daftar yang sudah urut

            // Langkah 5: Potong PDF
            output.textContent = `Mulai memotong ${processingList.length} file... (Langkah 5 dari 5)`;
            // Kirim daftar yang sudah urut
            const zip = await splitPdfDocuments(pdfFileBuffer, processingList, suffix);
            
            const processedFileNames = Object.keys(zip.files);
            if (processedFileNames.length === 0) {
                 throw new Error("Proses pemotongan selesai, tetapi tidak ada file PDF yang berhasil dibuat.");
            }

            output.textContent = `üì¶ Membuat file ZIP...`;
            const zipName = pdfFile.name.replace(/\.pdf$/i, '') + suffix + "_terpisah.zip";
            const zipBlob = await zip.generateAsync({ type: "blob" });
            downloadBytes(zipBlob, zipName, "application/zip");
            
            output.textContent = `üéâ Selesai! ${processedFileNames.length} file PDF berhasil dibuat di dalam .ZIP.`;
            output.className = "status-box status-success";

        } catch (err) {
            console.error("Kesalahan Utama:", err);
            output.textContent = `‚ùå Gagal! Kesalahan: ${err.message}`;
            output.className = "status-box status-error";
        } finally {
            isProcessing = false; startButton.disabled = false;
            pdfFile = null; txtFile = null; pdfFileBuffer = null;
            pdfDropZone.textContent = "Klik / Drop 1 File PDF";
            txtDropZone.textContent = "Klik / Drop 1 File .txt";
            pdfDropZone.classList.remove("has-file"); txtDropZone.classList.remove("has-file");
            startButton.disabled = true; 
        }
    });

    // --- 3. Fungsi Helper ---

    // Helper 1: Membaca file .txt (Tidak berubah)
    function readTxtFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split(/[\r\n]+/).map(line => line.trim()).filter(line => line.length > 0); 
                resolve(lines);
            };
            reader.onerror = (e) => reject(e);
            reader.readAsText(file);
        });
    }
    
    // Helper 2: Peta Pemisahan (Tidak berubah, tidak mengurutkan)
    async function createSplitMap(pdfjsDoc, uniqueCodes) {
        const pageCount = pdfjsDoc.numPages;
        const pageMap = [];
        const foundCodes = new Set();
        const normalize = (str) => str.replace(/\s/g, '').toLowerCase();

        const normalizedUniqueCodes = uniqueCodes.map(code => ({
            original: code,
            normalized: normalize(code)
        }));

        // (Logging di console bisa dihapus jika sudah tidak diperlukan)
        console.log("--- Normalisasi Kode Unik dari TXT ---");
        normalizedUniqueCodes.forEach(c => console.log(`  [${c.normalized}] (dari: ${c.original})`));
        console.log("-------------------------------------");

        for (let i = 1; i <= pageCount; i++) {
            const page = await pdfjsDoc.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(''); 
            const normalizedPageText = normalize(pageText);

            console.log(`--- Halaman ${i} ---`);
            console.log("Teks Normalisasi Halaman:", normalizedPageText);

            for (const codeEntry of normalizedUniqueCodes) {
                if (!foundCodes.has(codeEntry.original) && normalizedPageText.includes(codeEntry.normalized)) {
                    console.log(`   ---> MATCH Ditemukan: Kode [${codeEntry.normalized}] ditemukan di halaman ${i}.`);
                    pageMap.push({
                        code: codeEntry.original, 
                        page: i      
                    });
                    foundCodes.add(codeEntry.original); 
                }
            }
             console.log(`---------------------`);
        }
        // HAPUS PENGURUTAN DARI SINI
        return pageMap; // Kembalikan array yang ditemukan apa adanya
    }
    
    // Helper 3: Menampilkan Pratinjau (DIPERBARUI: menerima processingList)
    function renderPreviewList(processingList, suffix = '') {
        fileListContainer.innerHTML = ''; 
        
        // Loop berdasarkan processingList yang sudah urut
        for (let i = 0; i < processingList.length; i++) {
            const entry = processingList[i];
            
            const previewFileName = `${i + 1}. ${escapeHtml(entry.code)}${escapeHtml(suffix)}.pdf`;

            const div = document.createElement('div'); div.className = 'file-item';
            div.innerHTML = `
              <div class="file-info">
                <span class="file-name" title="${previewFileName}">${previewFileName}</span>
                <span class="file-size">Halaman ${entry.startPage} - ${entry.endPage}</span>
              </div>
              <div class="file-controls"> <span id="status-${i}" class="file-status pending">Menunggu...</span> </div>`;
            fileListContainer.appendChild(div);
        }
    }
    
    // Helper 4: Memotong PDF (pdf-lib) (DIPERBARUI: menerima processingList)
    async function splitPdfDocuments(pdfData, processingList, suffix = '') {
        const pdfDoc = await PDFDocument.load(pdfData.slice(0)); 
        const zip = new JSZip();
        
        // Loop berdasarkan processingList yang sudah urut
        for (let i = 0; i < processingList.length; i++) {
            const entry = processingList[i];
            const statusEl = document.getElementById(`status-${i}`);
            
            try {
                if (statusEl) { statusEl.textContent = 'Memproses... ‚è≥'; statusEl.className = 'file-status processing'; }

                const startPage = entry.startPage; 
                const endPage = entry.endPage;
                
                const newDoc = await PDFDocument.create();
                
                const pageIndicesToCopy = [];
                for (let p = startPage; p <= endPage; p++) {
                    pageIndicesToCopy.push(p - 1); // 0-based index
                }
                
                if (pageIndicesToCopy.length === 0) throw new Error("Rentang halaman kosong.");

                const copiedPages = await newDoc.copyPages(pdfDoc, pageIndicesToCopy);
                copiedPages.forEach(page => newDoc.addPage(page));
                
                const newBytes = await newDoc.save();
                
                const newFileName = `${i + 1}. ${entry.code}${suffix}.pdf`;
                zip.file(newFileName, newBytes);

                if (statusEl) { statusEl.textContent = '‚úÖ Selesai'; statusEl.className = 'file-status success'; }

            } catch (err) {
                 console.error(`Gagal memproses file: ${entry.code}`, err);
                 if (statusEl) { statusEl.textContent = '‚ùå Gagal'; statusEl.className = 'file-status error'; }
            }
        }
        
        return zip;
    }

    // Helper 5: Fungsi unduh
    function downloadBytes(bytes, filename, mimeType = 'application/pdf') {
      const blob = new Blob([bytes], { type: mimeType }); const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 60000);
    }
    
    // Helper 6: Escape HTML
    function escapeHtml(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

  </script>
</body>
</html>
